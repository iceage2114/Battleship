# Battleship game
Run Battleship.GUI

When the game is first initialized, a set of instructions at the top of the GUI is shown. The player places 4 ships, from lengths 2-5, and then the attacking phase starts. The player goes first by choosing a tile on the enemy waters (CPU's board). Then the CPU will attack a tile on the player's board. This continues until all ships on one side’s board are sunk. Then, a game over pop-up will be displayed. After each ship is sunk, there will also be a pop-up notifying which side and which ship has been sunk. The results of each turn are also displayed at the bottom of the GUI. At the end of the game, if the player loses, the enemy ships will be revealed. 

The person interacts with the game by attacking the CPU’s board and clicking “Ok” on the pop-ups. The skill component is strategically attacking tiles on the enemy board to maximize efficiency and strategically placing your ships to be hard to find. However, there is still naturally a luck component.

The design patterns I used were Strategy, Observer, and Factory. The Strategy pattern encapsulates different attack algorithms behind the AttackStrategy interface, allowing the CPU to switch between strategies at runtime based on game conditions. The CPUPlayer class maintains a reference to an AttackStrategy, which is initially set to SmartCPUStrategy and delegates attack decisions to it through the determineAttackPosition method. The SmartCPUStrategy acts as a strategy manager that contains two concrete strategies, RandomAttackStrategy and TargetedAttackStrategy, and automatically switches between them. It uses random attacks initially, switching to targeted attacks after hitting a ship, and reverting to random attacks after sinking a ship. The attack logic is decoupled from the CPU player class so new strategies can be added more easily, and the AI behavior can be dynamic.

The ShipFactory class implements the Factory pattern to create different types of ships. The factory uses the ShipType enum, which defines the available ship types (DESTROYER, SUBMARINE, BATTLESHIP, and CARRIER) along with their respective lengths. The ShipFactory takes a GameObserver in its constructor, ensuring that all created ships can notify observers when significant events, such as being sunk, occur. The createShip method uses a switch statement to instantiate the appropriate concrete subclass of Ship based on the ShipType. Adding a new ship type only requires updating the enum, creating a new subclass, and extending the switch statement. 

The Observer pattern is used to handle game events and notifications between the game components. The GameSubject abstract class, which both Ship and GameController extend, maintains a list of observers and provides methods to manage them. When important game events occur, such as a ship being sunk, the subject calls its notifyObservers() method, which in turn calls the update() method on all registered observers. The BattleshipGUI creates a GameLogger that gets registered with both the GameController and individual Ship objects. When events occur like successful attacks, misses, or ship sinkings, the subjects notify their observers, who then update the game log displayed in the GUI and show pop-up messages. For example, when a ship is sunk, the Ship class notifies its observers, which triggers both a log entry and a dialog box in the GUI, all without the Ship class needing direct knowledge of the GUI's implementation. 
